<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nuevos Tipos de Dato en JavaScript</title>
</head>

<body>
  <h1>Nuevos Tipos de Datos en JavaScript</h1>

  <script>

    /****************** SYMBOLS ****************/
    /*
      Es un tipo de dato primitivo, fue introducido
      en el estándar ecmascript 2015, al crearlo su valor
      se mantiene privado y de uso interno, nos
      permiten crear identificadores de referencia
      unica.

      La mayoría de sus usos es crear elementos
      privados dentro de un objeto y que tambien
      sus referencias van a ser unicas.

      Nos permiten tener identificadores únicos
      y generalmente se utilizan para crear
      propiedades privadas dentro de un objeto
    */

    // let id = Symbol('id');
    // let id2 = Symbol('id2');

    // console.log(id === id2);
    // console.log(id, id2);
    // console.log(typeof id, typeof id2);

    // const NAME = Symbol("name");
    // const GREET = Symbol("greets");

    // const person = {
    //   [NAME]: "Alan",
    //   edad: 25
    // }
    // console.log(person);

    // person.NAME = 'Alan Acosta';
    // console.log(person);
    // console.log(person.NAME);
    // console.log(person[NAME]);

    // person[GREET] = function () {
    //   console.log("Greetings");
    // }

    // console.log(person);
    // person[GREET]();

    // for (const propiedad in person) {
    //   console.log(propiedad);
    //   console.log(person[propiedad]);
    // }

    // console.log(Object.getOwnPropertySymbols(person));






    /********************* SETS *********************/
    /*
      Este nuevo de tipo de dato es una estructura
      de datos similar a un array pero de datos únicos
    */

    // const set = new Set([1, 1, false, false, 2, 3, 4, 5, 'aggh']);

    // console.log(set);
    // console.log(set.size);

    // const set2 = new Set();

    // set2.add(1);
    // set2.add(1);
    // set2.add(2);
    // set2.add(3);
    // set2.add('aggh');
    // set2.add('aggh');
    // set2.add('AGGH');

    // console.log(set2);
    // console.log(set2.size);

    // console.log("Recorriendo set");
    // for (const item of set) {
    //   console.log(item);
    // }

    // console.log("Recorriendo set2");

    // set2.forEach(item => console.log(item));

    // // un valor de tipo iterable es cualquier tipo
    // // de dato que permita contar sus elementos
    // let arr = Array.from(set);
    // console.log(arr);
    // console.log(arr[0]);

    // set2.delete('AGGH');
    // console.log(set2);

    // console.log(set.has('aggh'));
    // console.log(set.has(7));

    // set2.clear();
    // console.log(set2);







    /****************** MAPS ********************/
    /*
      son objetos que nos sirven para almacenar un
      conjunto de valores asociados a manera de
      objeto es parecido a un objeto primitivo,
      se usa como una coleccion de datos que estan
      relacionados entre si,
      para obtener sus valores trabajan de manera
      muy similar a los getters y setters de una
      clase POO
    */

    // const mapa = new Map();
    // mapa.set('nombre', 'alan');
    // mapa.set('apellido', 'Acosta');
    // mapa.set('edad', 25);
    // console.log(mapa);
    // console.log(mapa.size);
    // console.log(mapa.has("correo"));
    // console.log(mapa.has("nombre"));
    // console.log(mapa.get('nombre'));
    // mapa.set('nombre', 'bryan');

    // mapa.set(19, 'dorsal');
    // mapa.set(false, 'false');
    // console.log(mapa);

    // mapa.delete('apellido');
    // console.log(mapa);

    // for (const [key, value] of mapa) {
    //   console.log(`Llave: ${key}, Valor: ${value}`);
    // }

    // const mapa2 = new Map([
    //   ["nombre", 'messi'],
    //   ["edad", 32],
    //   ["posicion", "delantero"],
    //   [null, "nulo"]
    // ]);

    // console.log(mapa2);

    // const llavesMapa2 = [...mapa2.keys()];
    // const valoresMapa2 = [...mapa2.values()];

    // console.log(llavesMapa2);
    // console.log(valoresMapa2);






    /************** WeakSets & WeakMaps ********************/
    /*
          no se pueden iterar sobre las claves y valores
          no son iterables, no se pueden borrar de un jalon
          solo uno en uno, ni verificar su tamaño

          WeakSet: lo que hace es cuando algunas de
          sus propiedades se vuelve una referencia
          nula o no definida en automatico se
          eliminan

          WeakMap:
    */

    // const ws = new WeakSet([1, 1, 2, 2, 3, 4, 5, 'aggh']);
    // const ws = new WeakSet();
    // let valor1 = { "valor1": 1 };
    // let valor2 = { "valor2": 2 };
    // let valor3 = { "valor3": 3 };
    // ws.add(valor1);
    // ws.add(valor2);
    // console.log(ws);
    // console.log(ws);
    // console.log(ws.has(valor1));
    // console.log(ws.has(valor3));

    // ws.delete(valor2);
    // console.log(ws);

    // ws.add(valor2);
    // ws.add(valor3);
    // console.log(ws);

    // setInterval(() => console.log(ws), 1000);
    // setTimeout(() => {
    //   valor1 = null;
    //   valor2 = null;
    //   valor3 = null;
    // }, 5000);


    // const wm = new WeakMap({
    //   ["nombre", 'messi'],
    //   ["edad", 32],
    //   ["posicion", "delantero"],
    //   [null, "nulo"]
    // })

    // const wm = new WeakMap();
    // let llave1 = {};
    // let llave2 = {};
    // let llave3 = {};

    // wm.set(llave1, 1);
    // wm.set(llave2, 2);
    // console.log(wm);

    // console.log(wm.has(llave1));
    // console.log(wm.has(llave3));

    // console.log(wm.get(llave1));
    // console.log(wm.get(llave2));
    // console.log(wm.get(llave3));

    // wm.delete(llave2);
    // console.log(wm);

    // wm.set(llave2, 2);
    // wm.set(llave3, 3);
    // console.log(wm);

    // setInterval(() => console.log(wm), 1000);
    // setTimeout(() => {
    //   llave1 = null;
    //   llave2 = null;
    //   llave3 = null;
    // }, 500);







    /************** Iterables & Iterators ********************/
    /*
      que un dato sea iterable significa una
      estructura dedatos lineal que hace que sus
      elementos sean públicos y se puedan recorrer
      (arrays, strings, sets, maps e incluso
      elementos del DOM);

      iterable es el elemento cuyo contenido se
      puede recorrer

      iterador es ese apuntador/ mecanismo que
      esta recorriendo los elementos
    */
    //const iterable = [1, 2, 3, 4, 5];

    // accedemos al iterador del iterable
    // const iterador = iterable[Symbol.iterator]();

    // console.log(iterable);
    // console.log(iterador);
    // console.log(iterador.next());
    // console.log(iterador.next());
    // console.log(iterador.next());
    // console.log(iterador.next());
    // console.log(iterador.next());
    // console.log(iterador.next());

    /*
      son un mecanismo muy similar a los operadores
      que tienen los tipos de datos que son iterables
      como strings, map, set y array pero para volver
      el codigo de una funcion iterable
    */

    //const next = iterador.next();
    // const iterable = "Hola Mundo";
    // const iterable = new Set([1,2,3,4,5]);
    // const iterable = new Map([["nombre","alan"], ["edad",25]])";

    // while (!next.done) {
    //   console.log(next.value);
    //   next = iterador.next();
    // }






    /*************** GENERATORS ******************/
    /*
      Es una funcion que nos permite trabajar de una
      manera mas amigable con las interfaces de los
      iteradores en un elemento iterable
    */
    // function* iterable() {
    //   yield "hola";
    //   console.log("hola consola");
    //   yield "hola 2";
    //   console.log("Seguimos con mas instrucciones de nuestro codigo");
    //   yield "hola 3";
    //   yield "hola 4";
    // }

    // let iterador = iterable();
    // console.log(iterador.next());
    // console.log(iterador.next());
    // console.log(iterador.next());
    // console.log(iterador.next());

    // for (const y of iterador) {
    //   console.log(y);
    // }

    // const arr = [...iterable()];
    // console.log(arr);

    // function cuadrado(valor) {
    //   setTimeout(() => {
    //     return console.log({ valor, resultado: valor * valor })
    //   }, Math.random() * 1000);

    // }

    // function* generador() {
    //   console.log('Inicia Generator');
    //   yield cuadrado(0);
    //   yield cuadrado(1);
    //   yield cuadrado(2);
    //   yield cuadrado(3);
    //   yield cuadrado(4);
    //   yield cuadrado(5);
    //   console.log('Termina Generator');
    // }

    // let gen = generador();

    // for (let y of gen) {
    //   console.log(y);
    // }






    /********************* PROXIS ***************************/
    /*
      es un nuevo mecanismo de JS que permite
      crear un objeto basado en un objeto
      literal inicial

      el proxy hace una vinculacion entre el
      objeto original y el objeto copia y
      a traves de su manejador podemos hacer
      validaciones antes de hacer las asignaciones
    */

    // const persona = {
    //   nombre: "",
    //   apellido: "",
    //   edad: 0
    // }

    // const manejador = {
    //   set(obj, prop, valor) {
    //     if (Object.keys(obj).indexOf(prop) === -1) {
    //       return console.error(`La propiedad "${prop}" no existe en el objeto persona`);
    //     }

    //     if ((prop === 'nombre' || prop === 'apellido') && !(/^[A-Za-z\s]+$/g.test(valor))) {
    //       return console.error(`La propiedad "${prop}" solo acepta letras y espacios en blanco`);
    //     }
    //     obj[prop] = valor;
    //   }
    // }
    // const alan = new Proxy(persona, manejador);
    // alan.nombre = 'alan';
    // alan.apellido = 'acosta';
    // alan.edad = 25;
    // alan.twitter = '@alanacostabz';
    // console.log(alan);
    // console.log(persona);






    /********************* PROPIEDADES DINÁMICAS ***************************/
    /*
        https://jonmircha.com/
    */

    // let aleatorio = Math.round(Math.random() * 100 + 5);

    // const objetoUsuarios = {
    //   propiedad: "valor",
    //   [`id_${aleatorio}`]: "valor aleatorio"
    // };
    // console.log(objetoUsuarios);

    // const usuarios = ['alan', 'fernanda', 'cristiano'];

    // usuarios.forEach((usuario, index) => objetoUsuarios[`id_${index}`] = usuario);

    // console.log(objetoUsuarios);









  </script>
</body>

</html>